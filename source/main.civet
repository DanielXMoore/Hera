import type {
  HeraGrammar,
  HeraRules,
  ParserOptions,
} from ./machine.js

parser from ./parser.js
{compile as heraCompile} from ./compiler.civet
{ grammarToEBNF } from ./util.civet

execMod := (src: string) => {
  m := { exports: {} }
  Function("module", "exports", src)(m, m.exports)

  return m.exports
}

type CompilerOptions = {
  types?: boolean
  inlineMap?: boolean
  source?: string
  filename?: string
}

compile: (rulesOrString: HeraRules | string, options?: CompilerOptions) => string := (rulesOrString, options) =>
  let rules: HeraRules
  if typeof rulesOrString is "string"
    rules = parse(rulesOrString)
    if options
      options.source = rulesOrString
  else
    rules = rulesOrString

  return heraCompile rules, options

parse: <T extends HeraGrammar>(input: string, options?: ParserOptions<T>) => HeraRules := parser.parse

generate := <T extends HeraGrammar>(src: string) => {
  return execMod(compile(parse(src))) as {
    parse: (input: string, options?: ParserOptions<T>) => unknown
  }
}

export {
  parse
  compile
  generate
  grammarToEBNF
}

hera := {
  parse
  compile
  generate
}

export default hera
