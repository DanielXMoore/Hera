import type {
  HeraGrammar,
  HeraRules,
  ParserOptions,
} from ./hera-types.js

import { createRequire } from "module"

parser from ./parser.js
{ compile as heraCompile, type CompilerOptions } from ./compiler.civet
{ grammarToEBNF } from ./util.civet

require := createRequire(import.meta.url)

execMod := (src: string) => {
  m := { exports: {} }
  Function("require", "module", "exports", src)(require, m, m.exports)

  return m.exports
}

compile: (rulesOrString: HeraRules | string, options?: CompilerOptions) => string := (rulesOrString, options) =>
  let rules: HeraRules
  if typeof rulesOrString is "string"
    rules = parse(rulesOrString)
    if options
      options.source = rulesOrString
  else
    rules = rulesOrString

  return heraCompile rules, options

parse := parser.parse

generate := <T extends HeraGrammar>(src: string) => {
  return execMod(compile(parse(src))) as {
    parse: (input: string, options?: ParserOptions<T>) => unknown
  }
}

export {
  parse
  compile
  generate
  grammarToEBNF
}

hera := {
  parse
  compile
  generate
}

export default hera
