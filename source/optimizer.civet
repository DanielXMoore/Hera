import type { HeraAST, HeraRules, SequenceNode, SuffixNode, PrefixNode, Handler, PositionalVariable } from "./hera-types.ts"

optimizing := Symbol("optimizing")
type Optimizing = typeof optimizing

export optimize := (ast: HeraRules) ->
  optimized: Map<string, HeraAST | Optimizing> := new Map

  rules := Object.keys ast
  optimizeRule rules[0], optimized, ast
  Object.fromEntries optimized

optimizeRule := (ruleName: string, optimized: Map<string, HeraAST | Optimizing >, ast: HeraRules): HeraAST ->
  current := optimized.get(ruleName)

  if current is optimizing
    // Cyclic rule so we just return the rule name string
    return ruleName

  if current
    return current

  optimized.set ruleName, optimizing
  production := ast[ruleName]

  if production <? "string" // named rule alias
    optimizedRule := optimizeRule production, optimized, ast
    optimized.set ruleName, optimizedRule
    return optimizedRule

  optimizedRule := optimizeProduction production, optimized, ast

  optimized.set ruleName, optimizedRule
  return optimizedRule

isLiteral := (item: HeraAST) ->
  if item <? "string" or item.length !== 2
    return false

  [ kind ] := item

  return kind is "L" or kind is "R"

optimizeProduction := (production: HeraAST, optimized: Map<string, HeraAST | Optimizing>, ast: HeraRules): HeraAST ->
  if production <? "string"
    return optimizeRule production, optimized, ast

  switch production[0]
    when "S" // sequence
      optimizeSequence production, optimized, ast
    when "/" // Ordered Choice
      optimizeChoice production, optimized, ast
    when "*", "?", "+" // Quantifiers
      optimizeRepetition production, optimized, ast
    when "!", "&" // Assertions
      optimizeAssertion production, optimized, ast
    when "$" // Raw Text TODO
      optimizeProduction production[1], optimized, ast
    when "L", "R"
      production
    else
      throw new Error `Unknown production type: ${JSON.stringify(production[0])}`

optimizeChoice := (node: SequenceNode, optimized: Map<string, HeraAST | Optimizing>, ast: HeraRules): HeraAST ->
  items := node[1]

  if items.length is 0
    return ["L", ""]

  if items.length is 1
    return optimizeProduction items[0], optimized, ast

  optimizedItems := items.map (item) ->
    optimizeProduction item, optimized, ast

  if optimizedItems.every isLiteral
    literalItems := optimizedItems as ["L" | "R", string][]
    return combineLiteralChoice literalItems

  return node

optimizeRepetition := (node: SuffixNode, optimized: Map<string, HeraAST | Optimizing>, ast: HeraRules): HeraAST ->
  [kind, item, handler] := node

  optimizedItem := optimizeProduction item, optimized, ast

  if optimizedItem <? "string"
    return node

  if optimizedItem[0] is "R"
    return ["R", `(?:${optimizedItem[1]})${kind}`]

  if optimizedItem[0] is "L"
    return ["R", `(?:${regExpEscape optimizedItem[1]})${kind}`]

  return [ kind, optimizedItem, handler ]

optimizeAssertion := (node: PrefixNode, optimized: Map<string, HeraAST | Optimizing>, ast: HeraRules): HeraAST ->
  [kind, item] := node

  assertionType := kind is "&" ? "=" : "!"

  optimizedItem := optimizeProduction item, optimized, ast

  if optimizedItem <? "string"
    return node

  if optimizedItem[0] is "R"
    return ["R", `(?${assertionType}${optimizedItem[1]})`]

  if optimizedItem[0] is "L"
    return ["R", `(?${assertionType}${regExpEscape optimizedItem[1]})`]

  return [ kind, optimizedItem ]

optimizeSequence := (node: SequenceNode, optimized: Map<string, HeraAST | Optimizing>, ast: HeraRules): HeraAST ->
  items := node[1]
  handling := node[2]

  captureIndex .= handling and "v" in handling ? handling.v : -1

  optimizedItems := items.map (item) ->
    optimizeProduction item, optimized, ast

  // Join runs of adjacent literals
  { length } := items
  i .= 0
  resultItems := []
  pendingItems := []
  while i < length
    do
      item := optimizedItems[i]
      if isLiteral item
        pendingItems.push item
        i++
      else
        break
    while i < length

    if pendingItems.length > 1
      //@ts-ignore
      resultItems.push combineLiteralSequence pendingItems, captureIndex
    else if pendingItems.length is 1
      resultItems.push pendingItems[0]

    pendingItems.length = 0

    if i < length
      item := optimizedItems[i]
      resultItems.push item
      i++

  if resultItems.length is 0
    return ["L", ""]

  if resultItems.length is 1
    return resultItems[0]

  // TODO: remap handling
  if handling
    ["S", resultItems, handling]
  else
    ["S", resultItems]

combineLiteralChoice := (literals: ["L" | "R", string][]): ["L" | "R", string] ->
  [
    "R",
    literals.map ([k, s]) =>
      if k is "R"
        s
      else
        regExpEscape s
    .join("|")
  ]

combineLiteralSequence := (literals: ["L" | "R", string][], captureIndex: number): ["L" | "R", string, Handler?] ->
  kind := literals.every(([k]) -> k is "L") ? "L" : "R"
  let result: ["L" | "R", string, { v: PositionalVariable }?]

  if kind is "L"
    result = [kind, literals.map(([,s]) => s).join("")]
  else
    result = [
      kind,
      literals.map ([k, s], i) =>
        noCapture := captureIndex is i + 1 ? "" : "?:"
        // Wrap in a group to prevent merging with adjacent literals
        if k is "R"
          `(${noCapture}${s})`
        else
          if noCapture
            regExpEscape s
          else
            `(${regExpEscape s})`
      .join(""),
    ]

  if captureIndex > 0
    result.push v: 1

  return result

regExpEscape := (s: string): string ->
  s.replace /[-\/\\^$*+?.()|[\]{}]/g, "\\$&"
