// Compile a rules json to typescript

import type { HeraAST, StructuralHandling } from ./machine.js
{ readFileSync } from fs
{ dirname } from path
{ fileURLToPath } from url

interface CompileOptions {
  types: boolean
}

strDefs: string[] := []
reDefs: string[] := []

/**
Define a literal string terminal
*/
defineTerminal := (lit: string) ->
  index := strDefs.indexOf(lit)
  let id

  if index >= 0
    id = `$L${index}`
  else
    id = `$L${strDefs.length}`
    strDefs.push lit

  return id

/**
Define a RegExp terminal
*/
defineRe := (re: string) ->
  index := reDefs.indexOf(re)
  let id

  if index >= 0
    id = `$R${index}`
  else
    id = `$R${reDefs.length}`
    reDefs.push re

  return id

/**
Pretty print a string or RegExp literal
*/
prettyPrint := (name: string, terminal: string, re?: boolean) ->
  let pv
  if re
    pv = `/${terminal}/`
  else
    pv = JSON.stringify(terminal)

  return `${name} ${pv}`

/**
Compile an operator to a JS or TS string.
*/
compileOp := (tuple: HeraAST, name: string, defaultHandler: boolean, types: boolean): string ->
  // TODO: should nested levels have default handler set to true? (only comes into play on regexps)
  if Array.isArray(tuple)
    switch tuple[0]
      when "L"
        {
          args := tuple[1]
          `$EXPECT(${defineTerminal(args)}, fail, ${JSON.stringify(prettyPrint(name, args))})`
        }
      when "R"
        {
          args := tuple[1]
          let f = `$EXPECT(${defineRe(args)}, fail, ${JSON.stringify(prettyPrint(name, args, true))})`
          if defaultHandler
            f =`$R$0(${f})${reType(types, args)}`

          f
        }
      when "/"
        {
          src := tuple[1].map (arg) ->
            compileOp(arg, name, defaultHandler, types)
          .join(", ")

          `$C(${src})`
        }
      when "S"
        {
          src := tuple[1].map (arg) ->
            compileOp(arg, name, defaultHandler, types)
          .join(", ")
          `$S(${src})`
        }
      when "*"
        `$Q(${compileOp(tuple[1], name, defaultHandler, types)})`
      when "+"
        `$P(${compileOp(tuple[1], name, defaultHandler, types)})`
      when "?"
        `$E(${compileOp(tuple[1], name, defaultHandler, types)})`
      when "$"
        // Inside text can ignore all handlers since they are disregarded anyway
        `$TEXT(${compileOp(tuple[1], name, false, types)})`
      when "&"
        `$Y(${compileOp(tuple[1], name, defaultHandler, types)})`
      when "!"
        `$N(${compileOp(tuple[1], name, defaultHandler, types)})`
      default
        if tuple[0].name
          compileOp(tuple[1], name, defaultHandler, types)
        else
          throw new Error `Unknown op: ${tuple[0]} ${JSON.stringify(tuple[1])}`
  else // rule reference
    tuple

// Only rules have handlers, either one per choice line,
// or one for the whole deal

regExpHandlerParams := ["$skip", "$loc", "$0", "$1", "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9"]
regularHandlerParams := ["$skip", "$loc", "$0", "$1"]

// Offset is so sequences start at the first item in the array
// and regexps start at the second because the first is the entire match
// TODO: is 0 valid to select the entire sequence result?
// TODO: remove offset and unify handlings
compileStructuralHandler := (mapping: StructuralHandling, source: any, single=false, offset=-1): string ->
  switch typeof mapping
    when "string"
      JSON.stringify(mapping)
    when "object"
      if Array.isArray mapping
        `[${mapping.map((m) => compileStructuralHandler(m, source, single, offset)).join(', ')}]`
      else if mapping is null
        "null"
      else if "l" in mapping
        String(mapping.l)
      else if "v" in mapping
        if single
          source
        else
          if typeof mapping.v is 'number'
            n := mapping.v+offset
            if n is -1 // Handle $0
              source
            else // Handle $1, $2, etc.
              `${source}[${n}]`
          else
            mapping.v
      else if "o" in mapping
        o := mapping.o
        "{" + Object.keys(o).map (key) ->
          `${JSON.stringify(key)}: ${compileStructuralHandler(o[key], source, single, offset)}`
        .join(", ") + "}"
      else
        throw new Error "unknown object mapping"
    default // number, boolean, undefined
      String(mapping)

compileHandler := (options: CompileOptions, arg: HeraAST, name: string) ->
  if typeof arg is "string"
    return arg // reference to other named parser function

  if arg.length is 3
    h := arg[2]
    if h and typeof h is "object" and "f" in h // function mapping
      parser := compileOp(arg, name, false, options.types)

      if arg[0] is "S"
        // Gather names from each element in arg[1]
        // Only handle top level names for now
        // TODO: transform based on structure, walk AST tree to gather named parameters and mappings based on structural location
        namedParameters := arg[1].map (node, i) ->
          getParameterDeclaration(node, i+1)
        .join("")

        parameters := ["$skip", "$loc", "$0"].concat arg[1].map (_, i) => `$${i+1}`

        return `$TS(${parser}, function(${parameters.join(", ")}) {${namedParameters}${h.f}})`

      else if arg[0] is "R"
        // NOTE: RegExp named groups may go here later
        return `$TR(${parser}, function(${regExpHandlerParams.join(", ")}) {${h.f}})`
      else
        namedParameters := getParameterDeclaration(arg, 0)

        return `$TV(${parser}, function(${regularHandlerParams.join(", ")}) {${namedParameters}${h.f}})`

    else // structural mapping
      parser := compileOp(arg, name, false, options.types)
      if arg[0] is "S"
        namedParameters := arg[1].map (node, i) ->
          varName := getNamedVariable(node[0])
          if varName
            `var ${varName} = value[${i}];`
          else
            ""
        .join("")
        return `$T(${parser}, function(value) {${namedParameters}return ${compileStructuralHandler(h, "value")} })`
      else if arg[0] is "R"
        return `$T(${parser}, function(value) { return ${compileStructuralHandler(h, "value", false, 0)} })`
      else
        // This is 'single' so if there is a named variable it comes out as 'value'
        return `$T(${parser}, function(value) { return ${compileStructuralHandler(h, "value", true)} })`

  return compileOp(arg, name, true, options.types)

compileRule := (options: CompileOptions, name: string, rule: HeraAST) ->
  stateType := options.types ? ": ParseState" : ""

  // first level choice may have nested handlings
  if typeof rule is "string" or !(rule[0] is "/" and !rule[2])
    `
      const ${name}$0 = ${compileHandler(options, rule, name)};
      function ${name}(state${stateType}) {
        let eventData;
        if (state.events) {
          const result = state.events.enter?.(${JSON.stringify(name)}, state);
          if (result) {
            if (result.cache) return result.cache;
            eventData = result.data;
          }
        }
        if (state.tokenize) {
          const result = $TOKEN(${JSON.stringify(name)}, state, ${name}$0(state));
          if (state.events) state.events.exit?.(${JSON.stringify(name)}, state, result, eventData);
          return result;
        } else {
          const result = ${name}$0(state);
          if (state.events) state.events.exit?.(${JSON.stringify(name)}, state, result, eventData);
          return result;
        }
      }
    `
  else
    args := rule[1]
    fns := args.map (arg, i) ->
      `const ${name}$${i} = ${compileHandler options, arg, name};`

    choices := args.map (_, i) ->
      `${name}$${i}(state)`
    .join(" || ")

    `
      ${fns.join("\n")}
      function ${name}(state${stateType}) {
        let eventData;
        if (state.events) {
          const result = state.events.enter?.(${JSON.stringify(name)}, state);
          if (result) {
            if (result.cache) return result.cache;
            eventData = result.data;
          }
        }
        if (state.tokenize) {
          const result = $TOKEN(${JSON.stringify(name)}, state, ${choices});
          if (state.events) state.events.exit?.(${JSON.stringify(name)}, state, result, eventData);
          return result;
        } else {
          const result = ${choices};
          if (state.events) state.events.exit?.(${JSON.stringify(name)}, state, result, eventData);
          return result;
        }
      }
    `

compileRulesObject := (ruleNames: string[]) ->
  meat := ruleNames.map (name) ->
    `${name}: ${name}`
  .join(",\n")

  return `{
    ${meat}
  }`

/**
Get a JS declaration string for nodes that have named parameters.
*/
getParameterDeclaration := (node: HeraAST, i: number) ->
  name := getNamedVariable node[0]

  if name
    `var ${name} = $${i};`
  else
    ""

/**
Get a JS declaration string for nodes that have named parameters.
*/
getNamedVariable := (op: HeraAST[0]): string | undefined ->
  if typeof op is "object" and "name" in op
    return op.name
  return undefined

defaultOptions :=
  types: false

export function compile(rules: {[k: string]: HeraAST}, options=defaultOptions)
  // NOTE: This is only for building the Hera parser. `compile` won't magically work for other language parsers built.
  // TODO: Esbuild doesn't handle this correctly so the machine.* files need to be copied when bundling
  /* c8 ignore next */
  const dir = typeof __dirname !== "undefined" ? __dirname : dirname(fileURLToPath(import.meta.url));

  tsMachine := readFileSync(dir + "/machine.ts", "utf8")
  jsMachine := readFileSync(dir + "/machine.js", "utf8")

  { types } := options
  ruleNames := Object.keys(rules)

  body := ruleNames.map (name) ->
    compileRule(options, name, rules[name])
  .join("\n\n")

  header := types ? tsMachine : jsMachine

  return `${header}

  const { parse } = parserState(${compileRulesObject(ruleNames)})

  ${ strDefs.map (str, i) ->
    `const $L${i} = $L("${str}");`
  .join "\n" }

  ${ reDefs.map (r, i) ->
    `const $R${i} = $R(new RegExp(${JSON.stringify(r)}, 'suy'));`
  .join "\n" }

  ${body}

  exports.parse = parse
  exports.default = { parse }
  `

isSimple := /^[^.*+?{}()\[\]^\\]*$/
isSimpleCharacterClass := /^\[[^-^\\]*\]$/

/**
Generate a more specific TypeScript type for Regular expressions that consist of
limited productions. Returns an empty string if `types` is `false`.
*/
reType := (types: boolean, str: string) ->
  if types
    let specifics: string[] | undefined
    if str.match(isSimple)
      specifics = str.split("|").map (s) ->
        JSON.stringify(s)
    else if str.match(isSimpleCharacterClass)
      specifics = str.substring(1, str.length-1).split("").map (s) ->
        JSON.stringify(s)

    if specifics
      ` as Parser<${specifics.join("|")}>`
    else
      ""
  else
    ""
