// Generated by CoffeeScript 2.5.1
/*
Hand rolling a self compiling PEG compiler.

Inspired by https://github.com/kragen/peg-bootstrap/blob/master/peg.md

Goals
-----

- Single File
- Zero Dependencies
- Self-propagating
- Small
- Fast

---

Types

primitive handler:  string | number | [primitiveHandlers...]
rule handlers: primitiveHandler | f: function

location - # Maybe only need position?
  pos: start position
  length: length of token

state
  input: string
  pos: number - current input position

result
  loc: location - position and length of the matched token
  value: any - mapped value of the match
  pos: number - next input position

*/
var create;

// On 2019-07-25 at 11:11 PM it was first able to parse its decompiled rules and
// have them end up equal to the original rules!

// Notes
// ---

// 'S' receives an array that is splatted into $1, $2, ...
// The handlers for '*' and '+' always receive only one argument: an array in $1

// RegExp flags
// - s : dot matches newlines
// - u : match unicode
// - y : match from exact position
create = function(create, rules) {
  var RE_FLAGS, _names, decompile, fail, failExpected, failHintRegex, failIndex, fns, generate, getValue, hToS, invoke, loc, mapValue, maxFailPos, noteName, parse, preComputedRules, precompileHandler, precompute, precomputeRule, prettyPrint, toS, tokenHandler, validate;
  // Error tracking
  // Goal is zero allocations
  failExpected = Array(16);
  failIndex = 0;
  failHintRegex = /\S+|[^\S]+|$/y;
  maxFailPos = 0;
  fail = function(pos, expected) {
    if (pos < maxFailPos) {
      return;
    }
    if (pos > maxFailPos) {
      maxFailPos = pos;
      failIndex = 0;
    }
    failExpected[failIndex++] = expected;
  };
  // RegExp Flags
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp
  // Would like to add 's', but that kills IE11
  RE_FLAGS = "uy";
  // Pretty print a string or RegExp literal
  // TODO: could expand to all rules?
  // Includes looking up the name
  prettyPrint = function(v) {
    var name, pv, s;
    // Would prefer to use -v.flags.length, but IE doesn't support .flags
    pv = v instanceof RegExp ? (s = v.toString(), s.slice(0, s.lastIndexOf('/') + 1)) : typeof v === "string" ? v === "" ? "EOF" : JSON.stringify(v) : v;
    if (name = _names.get(v)) {
      return `${name} ${pv}`;
    } else {
      return pv;
    }
  };
  // Lookup to get Rule names from precomputed rules
  _names = new Map();
  noteName = function(name, value) {
    if (name) {
      _names.set(value, name);
    }
    return value;
  };
  // Transforming Rules into a pre-computed form
  preComputedRules = null;
  precomputeRule = function(rule, out, name, compile) {
    var arg, data, handler, op, placeholder, result;
    // Replace fn lookup with actual reference
    if (Array.isArray(rule)) { // op, arg, handler triplet or pair
      [op, arg, handler] = rule;
      result = [
        fns[op],
        (function() {
          switch (op) {
            case "/":
            case "S":
              return arg.map(function(x) {
                return precomputeRule(x,
        null,
        name,
        compile);
              });
            case "*":
            case "+":
            case "?":
            case "!":
            case "&":
              return precomputeRule(arg,
        null,
        name + op,
        compile);
            case "R":
              return noteName(name,
        RegExp(arg,
        RE_FLAGS));
            case "L":
              return noteName(name,
        JSON.parse("\"" + arg + "\""));
            default:
              throw new Error(`Don't know how to pre-compute ${JSON.stringify(op)}`);
          }
        })(),
        compile(handler,
        op,
        name)
      ];
      if (out) {
        // Replace placeholder content with actual content
        out[0] = result[0];
        out[1] = result[1];
        out[2] = result[2];
        return out;
      }
      return result; // rule name as a string
    } else {
      // Replace rulename string lookup with actual reference
      if (preComputedRules[rule]) {
        return preComputedRules[rule];
      } else {
        preComputedRules[rule] = placeholder = out || [];
        data = rules[rule];
        if (data == null) {
          throw new Error(`No rule with name ${JSON.stringify(rule)}`);
        }
        return precomputeRule(data, placeholder, rule, compile);
      }
    }
  };
  getValue = function(x) {
    return x.value;
  };
  // Return a function precompiled for the given handler
  // Handlers map result values into language primitives
  precompileHandler = function(handler, op) {
    var fn;
    if (handler != null ? handler.f : void 0) {
      fn = Function("$loc", "$0", "$1", "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9", handler.f);
      // Sequence spreads arguments out, all others only have one match
      // (terminals, choice, assertions, ?) or receive a single array (+, *)
      if (op === "S") {
        return function(s) {
          return fn.apply(null, [s.loc, s.value].concat(s.value));
        };
      } else if (op === "R") {
        return function(s) {
          return fn.apply(null, [s.loc].concat(s.value));
        };
      } else {
        return function(s) {
          return fn(s.loc, s.value, s.value);
        };
      }
    } else {
      if (op === "R") {
        if (handler != null) {
          return function(s) {
            return mapValue(handler, s.value); // Whole match
          };
        } else {
          return function(s) {
            return s.value[0];
          };
        }
      } else if (op === "S") {
        if (handler != null) {
          return function(s) {
            return mapValue(handler, [s.value].concat(s.value));
          };
        } else {
          return function(s) {
            return s.value;
          };
        }
      } else {
        return function(s) {
          return mapValue(handler, s.value);
        };
      }
    }
  };
  precompute = function(rules, compile) {
    var first;
    preComputedRules = {};
    first = Object.keys(rules)[0];
    preComputedRules[first] = precomputeRule(first, null, first, compile);
    return preComputedRules;
  };
  invoke = function(state, data) {
    var arg, fn, mapping, result;
    // console.log state.pos, prettyPrint data[1]
    [fn, arg, mapping] = data;
    result = fn(state, arg);
    if (mapping == null) {
      mapping = getValue;
    }
    if (result) {
      result.value = mapping(result);
    }
    return result;
  };
  // Converts a handler mapping structure into the mapped value
  // -> 1 (first item of sequence)
  // -> [2, 1] (array containing second and first item in that order)
  // -> [1, [4, 3]] (pair containing first, and a pair with 4th and 3rd item)
  // -> "yo" (literal "yo)
  // TODO: Map to object literals in a similar way?
  mapValue = function(mapping, value) {
    switch (typeof mapping) {
      case "number":
        return value[mapping];
      case "string":
        return mapping;
      case "object":
        if (Array.isArray(mapping)) {
          return mapping.map(function(n) {
            return mapValue(n, value);
          });
        } else {
          throw new Error("non-array object mapping");
        }
        break;
      case "undefined":
        return value;
      default:
        throw new Error("Unknown mapping type");
    }
  };
  // These are primitive functions that rules refer to
  fns = {
    L: function(state, str) { // String literal
      var input, length, pos;
      ({input, pos} = state);
      ({length} = str);
      if (input.substr(pos, length) === str) {
        return {
          loc: {
            pos: pos,
            length: length
          },
          pos: pos + length,
          value: str
        };
      } else {
        return fail(pos, str);
      }
    },
    // Match a regexp at state's position in the input
    // returns new position and value of matching string
    R: function(state, regExp) { // Regexp Literal
      var input, l, m, pos, v;
      ({input, pos} = state);
      regExp.lastIndex = state.pos;
      if (m = input.match(regExp)) {
        v = m[0];
      }
      if (v != null) {
        l = v.length;
        return {
          loc: {
            pos: pos,
            length: l
          },
          pos: pos + l,
          value: m
        };
      } else {
        return fail(pos, regExp);
      }
    },
    // a b c ...
    // a followed by b ...
    S: function(state, terms) {
      var i, input, l, pos, r, results, s, value;
      ({input, pos} = state);
      results = [];
      s = pos;
      i = 0;
      l = terms.length;
      while (true) {
        r = invoke({input, pos}, terms[i++]);
        if (r) {
          ({pos, value} = r);
          results.push(value);
        } else {
          return;
        }
        if (i >= l) {
          break;
        }
      }
      return {
        loc: {
          pos: s,
          length: pos - s
        },
        pos: pos,
        value: results
      };
    },
    // a / b / c / ...
    // Proioritized choice
    // roughly a(...) || b(...) in JS, generalized to reduce, optimized to loop
    "/": function(state, terms) {
      var i, l, r;
      i = 0;
      l = terms.length;
      while (true) {
        r = invoke(state, terms[i++]);
        if (r) {
          return r;
        }
        if (i >= l) {
          break;
        }
      }
    },
    // a? zero or one
    "?": function(state, term) {
      return invoke(state, term) || state;
    },
    // a*
    // NOTE: zero length repetitions (where position doesn't advance) return
    // an empty array of values. A repetition where the position doesn't advance
    // would be an infinite loop, so this avoids that problem cleanly.
    // TODO: Think through how this interacts with & and ! predicates
    "*": function(state, term) {
      var input, pos, prevPos, r, results, s, value;
      ({input, pos} = state);
      s = pos;
      results = [];
      while (true) {
        prevPos = pos;
        r = invoke({input, pos}, term);
        if (r == null) {
          break;
        }
        ({pos, value} = r);
        if (pos === prevPos) {
          break;
        } else {
          results.push(value);
        }
      }
      return {
        loc: {
          pos: s,
          length: pos - s
        },
        pos: pos,
        value: results
      };
    },
    // a+ one or more
    "+": function(state, term) {
      var first, input, pos, rest, s;
      ({
        input,
        pos: s
      } = state);
      first = invoke(state, term);
      if (first == null) {
        return;
      }
      ({pos} = first);
      ({pos} = rest = invoke({input, pos}, [fns["*"], term]));
      rest.value.unshift(first.value);
      return {
        loc: {
          pos: s,
          length: pos - s
        },
        value: rest.value,
        pos: pos
      };
    },
    "!": function(state, term) {
      var newState;
      newState = invoke(state, term);
      if (newState != null) {

      } else {
        return state;
      }
    },
    "&": function(state, term) {
      var newState;
      newState = invoke(state, term);
      // If the assertion doesn't advance the position then it is failed.
      // A zero width assertion always succeeds and is useless
      if (newState.pos === state.pos) {

      } else {
        return state;
      }
    }
  };
  // Compute the line and column number of a position (used in error reporting)
  loc = function(input, pos) {
    var column, line, rawPos;
    rawPos = pos;
    [line, column] = input.split(/\n|\r\n|\r/).reduce(function([row, col], line) {
      var l;
      l = line.length + 1;
      if (pos > l) {
        pos -= l;
        return [row + 1, 1];
      } else if (pos >= 0) {
        col += pos;
        pos = -1;
        return [row, col];
      } else {
        return [row, col];
      }
    }, [1, 1]);
    return `${line}:${column}`;
  };
  validate = function(input, result, {filename}) {
    var expectations, hint, l;
    if ((result != null) && result.pos === input.length) {
      return result.value;
    }
    expectations = Array.from(new Set(failExpected.slice(0, failIndex)));
    l = loc(input, maxFailPos);
    // The parse completed with a result but there is still input
    if ((result != null) && result.pos > maxFailPos) {
      l = loc(input, result.pos);
      throw new Error(`Unconsumed input at ${l}

${input.slice(result.pos)}
`);
    } else if (expectations.length) {
      failHintRegex.lastIndex = maxFailPos;
      [hint] = input.match(failHintRegex);
      if (hint.length) {
        hint = prettyPrint(hint);
      } else {
        hint = "EOF";
      }
      throw new Error(`${filename}:${l} Failed to parse
Expected:
\t${expectations.map(prettyPrint).join("\n\t")}
Found: ${hint}`);
    } else {
      throw new Error(`Unconsumed input at ${l}

${input.slice(result.pos)}
`);
    }
  };
  parse = function(input, opts = {}) {
    var result, state;
    if (typeof input !== "string") {
      throw new Error("Input must be a string");
    }
    if (opts.filename == null) {
      opts.filename = "[stdin]";
    }
    // Init error tracking
    failIndex = 0;
    maxFailPos = 0;
    state = {
      input,
      pos: 0
    };
    // TODO: This breaks pre-computed rules for subsequent non-tokenized calls
    if (opts.tokenize) {
      precompute(rules, tokenHandler);
    }
    result = invoke(state, Object.values(preComputedRules)[0]);
    return validate(input, result, opts);
  };
  // Ignore result handlers and return type tokens based on rule names
  tokenHandler = function(handler, op, name) {
    return function({value}) {
      if (value == null) {
        return value;
      }
      switch (op) {
        case "S":
          return {
            type: name,
            value: value.filter(function(v) {
              return v != null;
            }).reduce(function(a, b) {
              return a.concat(b);
            }, [])
          };
        case "L":
        case "R": // Terminals
          return {
            type: name,
            value: value
          };
        case "*":
        case "+":
          return {
            type: op,
            value: value
          };
        case "?":
        case "/":
          return value;
        case "!":
        case "&":
          return {
            type: op + name,
            value: value
          };
      }
    };
  };
  // Generate the source for a new parser for the given rules
  // if vivify is true return a parser object from the evaluated source
  generate = function(rules, vivify) {
    var m, src;
    src = `(function(create, rules) {
  create(create, rules);
}(${create.toString()}, ${JSON.stringify(rules)}));
`;
    if (vivify) {
      m = {};
      Function("module", src)(m);
      return m.exports;
    } else {
      return src;
    }
  };
  // handler to source
  hToS = function(h) {
    if (h == null) {
      return "";
    }
    return " -> " + (function() {
      switch (typeof h) {
        case "number":
          return h;
        case "string":
          return JSON.stringify(h);
        case "object":
          if (Array.isArray(h)) {
            return JSON.stringify(h);
          } else {
            return `\n${h.f.replace(/^|\n/g, "$&    ")}`;
          }
      }
    })();
  };
  // toS and decompile generate a source document from the rules AST
  toS = function(rule, depth = 0) {
    var f, h, terms;
    if (Array.isArray(rule)) {
      f = rule[0];
      h = rule[2];
      switch (f) {
        case "*":
        case "+":
        case "?":
          return toS(rule[1], depth + 1) + f + hToS(h);
        case "&":
        case "!":
          return f + toS(rule[1], depth + 1);
        case "L":
          return '"' + rule[1] + '"' + hToS(h);
        case "R":
          return '/' + rule[1] + '/' + hToS(h);
        case "S":
          terms = rule[1].map(function(i) {
            return toS(i, depth + 1);
          });
          if (depth < 1) {
            return terms.join(" ") + hToS(h);
          } else {
            return "( " + terms.join(" ") + " )";
          }
          break;
        case "/":
          terms = rule[1].map(function(i) {
            return toS(i, depth && depth + 1);
          });
          if (depth === 0 && !h) {
            return terms.join("\n  ");
          } else {
            return "( " + terms.join(" / ") + " )" + hToS(h); // String name of the rule
          }
      }
    } else {
      return rule;
    }
  };
  // Convert the rules to source text in hera grammar
  decompile = function(rules) {
    return Object.keys(rules).map(function(name) {
      var value;
      value = toS(rules[name]);
      return `${name}\n  ${value}\n`;
    }).join("\n");
  };
  // Pre compile the rules and handler functions
  precompute(rules, precompileHandler);
  return module.exports = {
    decompile: decompile,
    parse: parse,
    generate: generate,
    rules: rules
  };
};

// Create a parser with rules for the Hera grammar
create(create, require("./rules"));
