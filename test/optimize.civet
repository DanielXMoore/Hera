{ optimize } from ../source/optimizer.civet
import type { HeraRules } from ../source/hera-types.ts
assert from assert

describe.only "AST Optimization", ->
  it "should convert sequences of string literals into a single string literal", ->
    ast: HeraRules := {
      "Rule": [ "S", [
        [ "L", "a" ],
        [ "L", "b" ],
        [ "L", "c" ]
      ]]
    }

    optimized: HeraRules := {
      "Rule": [ "L", "abc" ]
    }

    assert.deepEqual optimize(ast), optimized

  it "should convert sequences of strings and regexps into a single regexp literal", ->
    ast: HeraRules := {
      "Rule": [ "S", [
        [ "L", "a" ],
        [ "R", "[^c]*" ],
        [ "L", "c" ]
      ]]
    }

    optimized: HeraRules := {
      "Rule": [ "R", "a(?:[^c]*)c" ]
    }

    assert.deepEqual optimize(ast), optimized

  it "should optimize sequences and choices with aliases", ->
    ast: HeraRules :=
      "CharacterClass": [ "S", [
        [ "L", "[" ],
        [ "*", "CharacterClassCharacter" ],
        [ "L", "]" ],
        [ "?", "Quantifier" ]
      ]],
      "CharacterClassCharacter": [ "/", [
        [ "R", "[^\\]\\\\]+" ],
        "EscapeSequence"
      ]],
      "EscapeSequence": [ "$", [ "S", [
        "Backslash",
        ["R", "." ]
      ]]],
      "Backslash": [ "L", "\\\\" ],
      "Quantifier":
        [ "R", "[?+*]|\\{\\d+(,\\d+)?\\}" ],

    optimized: HeraRules := {
      "CharacterClass": [ "R", "\\[(?:(?:[^\\]\\\\]+|\\\\\\\\(?:.))*)\\](?:(?:[?+*]|\\{\\d+(,\\d+)?\\})?)" ],
      "CharacterClassCharacter": [ "R", "[^\\]\\\\]+|\\\\\\\\(?:.)" ],
      "EscapeSequence": [ "R", "\\\\\\\\(?:.)" ],
      "Backslash": [ "L", "\\\\" ],
      "Quantifier":
        [ "R", "[?+*]|\\{\\d+(,\\d+)?\\}" ],
    }

    assert.deepEqual optimize(ast), optimized

  it "should optimize what it can even with cyclic rules", ->
    ast: HeraRules :=
      "Rule": [ "S", [
        [ "L", "(" ],
        [ "L", " " ],
        "Rule",
        [ "L", " " ],
        [ "L", ")" ],
      ]]

    optimized: HeraRules :=
      "Rule": [ "S", [
        [ "L", "( " ],
        "Rule",
        [ "L", " )" ],
      ]]

    assert.deepEqual optimize(ast), optimized
